<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>An Introduction to Finch</title>

		<meta name="description" content="An Introduction to Finch">
		<meta name="author" content="Ryan Plessner">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/solarized.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>
		<div class="reveal">
			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h2>An Introduction to Finch</h2>
					<p>
						<small>Ryan Plessner | <a href="http://twitter.com/ryan_plessner">@ryan_plessner</a></small>
					</p>
				</section>

				<section>
					<section>
						<h2>What is Finch?</h2>
						<img class="no-border" src="https://raw.githubusercontent.com/finagle/finch/master/finch-logo.png"  />
						<br/>
						<a target="_blank" href="https://www.github.com/finagle/finch">github.com/finagle/finch</a>
						<br/>
						<img class="no-border" src="https://travis-ci.org/finagle/finch.svg?branch=master" />
						<img class="no-border" src="http://codecov.io/github/finagle/finch/coverage.svg?branch=master" alt="Coverage via codecov.io" />

						<aside class="notes">
							Open Source Project in the Finagle ecosystem. <br />
							Provides a more idiomatic and Functional Finagle-Http. <br />
							Its been around since April, I started contributing in August <br />
						</aside>
					</section>

					<section>
						<h2>Built on Finagle</h2>
						<img class="no-border" src="https://camo.githubusercontent.com/5817603f4c475459b07f31d6df1a1cecb29f34dd/68747470733a2f2f7261772e6769746875622e636f6d2f747769747465722f66696e61676c652f6d61737465722f646f632f7372632f737068696e782f5f7374617469632f6c6f676f5f736d616c6c2e706e67" width="360px"/>
						<br />
						<a target="_blank" href="https://twitter.github.io/finagle/">twitter.github.io/finagle/</a>

						<aside class="notes">
							Extensible RPC system for the JVM used mainly to construct high-concurrency systems. <br />
							Protocol Agnostic. <br />
							Particularly interested in the Http library which is built on Netty 3. <br />
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h2>Quick Finagle Overview</h2>
						<aside class="notes">
							Quick review of Finagle's core concepts for those that haven't used it. <br />
							"Your Server as a Function" <br />
							Implements interfaces for both clients and servers <br />
							Only going to focus on Server side. <br />
						</aside>
					</section>
					<section>
						<h2>Futures</h2>
						<ul>
							<li>Lightweight</li>
							<li>Composable</li>
						</ul>

						<aside class="notes">
							Composable Concurrent Operations.  <br />
							Threads are really lightweight.    <br />
							States: Pending, Suceeded, Failed  <br />
							Compose with flatmap and onSuccess <br />
							Recover with recover and onFailure <br />
						</aside>
					</section>

					<section>
						<h2>Services</h2>
						<p>Req => Future[Rep]</p>
					<aside class="notes">
						Implement Application Logic <br />
						Its just a function. <br />
						Backbone of server implementations. <br />
					</aside>
					</section>

					<section>
						<h2>Filters</h2>
						<p>(ReqIn, Service[ReqOut, RepIn]) => Future[RepOut]<p/>

						<aside class="notes">
							Also a function. <br />
							Given a request and the next Service in the Chain. <br />
							Most commonly used where Requests and Responses are the same type. <br />
						</aside>
					</section>

					<section>
						<h3>Filters and Services are Composable</h3>
						<aside class="notes">
							Composed using the andthen function. <br />
							Can compose services and filters <br />
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h2>Let's Build a Something with Finch</h2>
						<aside class="notes">
							We'll walk through a simple example to show how powerful finch is <br />
							Services from Request => Future[Response]
						</aside>
					</section>

					<section>
						<h2>What are we looking to solve?</h2>
						<h3>Simple Commenting Service</h3>

						<aside class="notes">
							Super Contrived Example: <br />
							You have a website that needs a way for users to add comments. <br />
							Anyone can view comments, but only authed users can comment <br />
							We're gonna do a lot of hand waving as a result. <br />
						</aside>
					</section>

					<section>
						<h2>Modeling our data</h2>

						<pre>
							<code class="scala">
case class CommentThread(id: Long, comments: Seq[Comment])

case class Comment(id: Option[Long], commenter: String, text: String)
							</code>
						</pre>
					</section>
				</section>

				<section>
					<section>
						<h1>Requests</h1>
						<p>
							import io.finch.request._
						</p>
						<aside class="notes">
							Based on HTTP Requests <br />
							How do we extract data from the requests <br />
						</aside>
					</section>

					<section>
						<h2>Request Readers</h2>
						<pre>
							<code class="scala">
val commentReader = body.as[Comment]
							</code>
						</pre>
						<aside class="notes">
							A Reader Monad for handling requests <br />
							Readers for `params`, `headers`, `body`, `files`, and more... <br />
						</aside>
					</section>

					<section>
						<h2>Decode Request</h2>
						<pre>
							<code class="scala">
import io.finch.argonaut._
import argonaut._, Argonaut._

implicit val commentCodec: DecodeJson[Comment] =
  jdecode3L(Comment.apply)("id", "commenter", "text")

implicit val commentThreadCodec: DecodeJson[CommentThread] =
  jdecode2L(CommentThread.apply)("id", "comments")
							</code>
						</pre>
						<aside class="notes">
							Type Class <br />
							implicits to convert the Type of Request Readers <br />
						</aside>
					</section>

					<section>
						<h2>Alternative Comment Reader</h2>
						<pre>
							<code class="scala">
val commentReader = for {
  commenter <- param("commenter")
  text <- body
} yield Comment(None, commenter, text)
							</code>
						</pre>
						<aside class="notes">
							What if its not all on the Body? That's ok. <br />
							Its a Monad so we can use scala's `for` <br />
							Is there a problem here?
						</aside>
					</section>

					<section>
						<h2>Applicative Comment Reader</h2>
						<pre>
							<code class="scala">
val commentReader = (
  paramOption("id").as[Long] ::
  param("commenter") ::
  body
).as[Comment]
							</code>
						</pre>
						<aside class="notes">
							Applicative <br />
							Gives you all the errors <br />
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h1>Response</h1>
						<p>
							import io.finch._
						</p>
						<aside class="notes">
							Based on HTTP Responses <br />
							How do we convert data to a request <br />
						</aside>
					</section>

					<section>
						<h2>Simple Requests</h2>
						<pre>
							<code class="scala">
Ok()
Created("Some String").withHeaders("Cache-Control", "public")
							</code>
						</pre>
						<aside class="notes">
							How does this work? <br />
							Can set cookies, headers, etc <br />
							EncodeResponse <br />
						</aside>
					</section>

					<section>
						<h2>More Interesting Response Bodies</h2>
						<pre>
							<code class="scala">
Created(Comment(Some(1234), "Ryan", "A Comment!"))
							</code>
						</pre>
						<aside class="">
							Can Encode a Case class as the body of an HTTP Response <br />
						</aside>
					</section>

					<section>
						<h2>Encode Response</h2>
						<pre>
							<code class="scala">
import io.finch.argonaut._

val extractComment = (c: Comment) => (c.id, c.commenter, c.text)

implicit val encodeComment: EncodeJson[Comment] =
  jencode3L(extractComment)("id", "commenter", "text")
							</code>
						</pre>
						<aside class="notes">
							finch argonaut provides Json => Response <br />
							Just like Decode Requests <br />
							implicit conversions <br />
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h1>Endpoint</h1>
						<p>
							import io.finch._
							<br />
							import io.finch.Endpoint
						</p>
						<aside class="notes">
							Need to turn Requests into to Responses <br />
							Matchers attempt to match against HTTP Request. <br />
							Can include Method type, URI Path, and Request Readers <br />
							Maps to Functions that produce responses <br />
							TypeSafe Extraction.
						</aside>
					</section>

					<section>
						<h2>Wiring it up</h2>
						<pre>
							<code class="scala">
def listCommentThreads(config: AppConfig): Endpoint[Response] =
  get("thread") { Ok(config.commentThreadRepo.list()) }
							</code>
						</pre>
						<aside class="notes">
							Matches on a GET request to the path /thread <br />
							Maps a Request into a Response
						</aside>
					</section>

					<section>
						<h2>Extracting Value from Endpoints</h2>
						<pre>
							<code class="scala">
def getCommentThread(config: AppConfig): Endpoint[CommentThread] =
  get("thread" / long) { (id: Long) =>
    Ok(config.commentThreadRepo.get(id))
  }
							</code>
						</pre>
						<aside class="notes">
							Extract Path value <br />
							And magically pass it to the mapped function. <br />
							Endpoints will automatically wrap values in.
							Also gives us Endpoints of a more interesting type
						</aside>
					</section>

					<section>
						<h2>Request Readers in Endpoints</h2>
						<pre>
							<code class="scala">
def createComment(config: AppConfig): Endpoint[Comment] = {
  post("thread" / long / "comment" ? commentReader) {
    (threadId: Long, comment: Comment) =>
    Created(config.commentThreadRepo.createComment(threadId, comment))
  }
							</code>
						</pre>
						<aside class="notes">
							Use Request Reader to extract the value we care about
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h1>Putting it All Together</h1>
					</section>

					<section>
						<h2>Main</h2>
						<pre>
							<code class="scala">
import io.finch.argonaut._
import io.github.rpless.finchintro.endpoint.CommentThreadEndpoints

object Main extends App {
  import CommentThreadEndpoints._
  val config: AppConfig = ???

  var endpoints =
    listCommentThreads(config) :+:
    getCommentThread(config) :+:
    createComment(config)

  Await.ready(Httpx.serve(":8080", endpoints.toService))
}
							</code>
						</pre>
						<aside class="scala">
							CoProduct Endpoint <br />
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h1>Other Goodies</h1>
					</section>

					<section>
						<h2>Request Reader Validation</h2>
						<pre>
							<code class="scala">
val commentParamReader = (
  paramOption("id").as[Long].should("Be Empty") { _.isEmpty } ::
  param("commenter") ::
  body
).as[Comment]
							</code>
						</pre>
					</section>

					<section>
						<h2>JSON Library Support</h2>
						<ul>
							<li>Argonaut</li>
							<li>Circe</li>
							<li>Jackson</li>
							<li>Json4s</li>
						</ul>
					</section>

					<section>
						<h2>File Uploads</h2>
					</section>
				</section>

				<section>
					<section>
						<h1>Questions?</h1>
					</section>

					<section>
						<h1>Thanks!</h1>
					</section>

					<section>
						<h2>Resources</h2>
						<ul>
							<li><a target="_blank" href="http://monkey.org/~marius/funsrv.pdf">Your Server as a Function</a></li>
							<li><a target="_blank" href="https://github.com/finagle/finch/blob/master/docs/index.md">Finch Docs</a></li>
							<li><a target="_blank" href="https://github.com/finagle/finch/tree/master/petstore">Petstore Example</a></li>
							<li><a target="_blank" href="https://github.com/vkostyukov/finch-101">Finch 101</a></li>
						</ul>
					</section>
				</section>

			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});
		</script>
	</body>
</html>
