<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>An Introduction to Finch</title>

		<meta name="description" content="An Introduction to Finch">
		<meta name="author" content="Ryan Plessner">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/solarized.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>
		<div class="reveal">
			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h2>An Introduction to Finch</h2>
					<p>
						<small>Ryan Plessner | <a href="http://twitter.com/ryan_plessner">@ryan_plessner</a></small>
					</p>
				</section>

				<section>
					<section>
						<h2>What is Finch?</h2>
						<img class="no-border" src="https://raw.githubusercontent.com/finagle/finch/master/finch-logo.png"  />
						<br/>
						<a target="_blank" href="https://www.github.com/finagle/finch">github.com/finagle/finch</a>
						<br/>
						<img class="no-border" src="https://travis-ci.org/finagle/finch.svg?branch=master" />
						<img class="no-border" src="http://codecov.io/github/finagle/finch/coverage.svg?branch=master" alt="Coverage via codecov.io" />

						<aside class="notes">
							Open Source Project in the Finagle ecosystem. <br />
							Provides a more idiomatic and Functional Finagle-Http. <br />
							Its been around since April, I started contributing in August <br />
						</aside>
					</section>

					<section>
						<h2>Built on Finagle</h2>
						<img class="no-border" src="https://camo.githubusercontent.com/5817603f4c475459b07f31d6df1a1cecb29f34dd/68747470733a2f2f7261772e6769746875622e636f6d2f747769747465722f66696e61676c652f6d61737465722f646f632f7372632f737068696e782f5f7374617469632f6c6f676f5f736d616c6c2e706e67" width="360px"/>
						<br />
						<a target="_blank" href="https://twitter.github.io/finagle/">twitter.github.io/finagle/</a>

						<aside class="notes">
							Extensible RPC system for the JVM used mainly to construct high-concurrency systems. <br />
							Protocol Agnostic. <br />
							Particularly interested in the Http library which is built on Netty 3. <br />
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h2>Quick Finagle Overview</h2>
						<aside class="notes">
							Quick review of Finagle's core concepts for those that haven't used it. <br />
							"Your Server as a Function" <br />
							Implements interfaces for both clients and servers <br />
							Only going to focus on Server side. <br />
						</aside>
					</section>
					<section>
						<h2>Futures</h2>
						<ul>
							<li>Featherweight Threads</li>
							<li>Composable</li>
						</ul>

						<aside class="notes">
							Composable Concurrent Operations.  <br />
							Threads are really lightweight.    <br />
							States: Pending, Suceeded, Failed  <br />
							Compose with flatmap and onSuccess <br />
							Recover with recover and onFailure <br />
						</aside>
					</section>

					<section>
						<h2>Services</h2>
						<p>Req => Future[Rep]</p>
					<aside class="notes">
						Implement Application Logic <br />
						Its just a function. <br />
						Backbone of server implementations. <br />
					</aside>
					</section>

					<section>
						<h2>Filters</h2>
						<p>(ReqIn, Service[ReqOut, RepIn]) => Future[RepOut]<p/>

						<aside class="notes">
							Also a function. <br />
							Given a request and the next Service in the Chain. <br />
							Most commonly used where Requests and Responses are the same type. <br />
						</aside>
					</section>

					<section>
						<h3>Filters and Services are Composable</h3>
						<aside class="notes">
							Composed using the andthen function. <br />
							Can compose services and filters <br />
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h2>Let's Build a Something with Finch</h2>
						<aside class="notes">
							We'll walk through a simple example to show how powerful finch is <br />
							Services from Request => Future[Response]
						</aside>
					</section>

					<section>
						<h2>What are we looking to solve?</h2>
						<h3>Simple Commenting Service</h3>

						<aside class="notes">
							Super Contrived Example: <br />
							You have a website that needs a way for users to add comments. <br />
							Anyone can view comments, but only authed users can comment <br />
							We're gonna do a lot of hand waving as a result. <br />
						</aside>
					</section>

					<section>
						<h2>Modeling our data</h2>

						<pre>
							<code class="scala">
case class CommentThread(id: Long, comments: Seq[Comment])

case class Comment(id: Option[Long], commenter: String, text: String)
							</code>
						</pre>
					</section>
				</section>

				<section>
					<section>
						<h1>Requests</h1>
						<aside class="notes">
							Based on HTTP Requests <br />
							How do we extract data from the requests <br />
						</aside>
					</section>

					<section>
						<h2>Request Readers</h2>
						<pre>
							<code class="scala">
val commentReader = body.as[Comment]
							</code>
						</pre>
						<aside class="notes">
							A Reader Monad for handling requests <br />
							Readers for `params`, `headers`, `body`, `files`, and more... <br />
						</aside>
					</section>

					<section>
						<h2>Decode Request</h2>
						<pre>
							<code class="scala">
import io.finch.argonaut._
import argonaut._, Argonaut._

implicit val commentCodec: DecodeJson[Comment] =
  jdecode3L(Comment.apply)("id", "commenter", "text")

implicit val commentThreadCodec: DecodeJson[CommentThread] =
  jdecode2L(CommentThread.apply)("id", "comments")
							</code>
						</pre>
						<aside class="notes">
							Type Class <br />
							implicits to convert the Type of Request Readers <br />
						</aside>
					</section>

					<section>
						<h2>Alternative Comment Reader</h2>
						<pre>
							<code class="scala">
val commentReader = for {
  commenter <- param("commenter")
  text <- body
} yield Comment(None, commenter, text)
							</code>
						</pre>
						<aside class="notes">
							What if its not all on the Body? That's ok. <br />
							Its a Monad so we can use scala's `for` <br />
							Is there a problem here?
						</aside>
					</section>

					<section>
						<h2>Applicative Comment Reader</h2>
						<pre>
							<code class="scala">
								val commentReader = (
								  paramOption("id").as[Long] ::
								  param("commenter") ::
								  body
								).as[Comment]
							</code>
						</pre>
						<aside class="notes">
							Applicative <br />
							Gives you all the errors <br />
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h1>Response</h1>
						<aside class="notes">
							Based on HTTP Responses <br />
							How do we convert data to a request <br />
						</aside>
					</section>

					<section>
						<pre>
							<code class="scala">
Ok()
NotFound("Invalid Resource")
Created(Comment(Some(1234), "Ryan", "A Comment!"))
							</code>
						</pre>
						<aside class="notes">
							How does this work? <br />
							EncodeResponse <br />
						</aside>
					</section>

					<section>
						<h2>Encode Response</h2>
						<pre>
							<code class="scala">
import io.finch.argonaut._

implicit val encodeComment: EncodeJson[Comment] =
  jencode3L((c: Comment) => (c.id, c.commenter, c.text))("id", "commenter", "text")
							</code>
						</pre>
						<aside class="notes">
							Just like Decode Requests <br />
							implicit conversions <br />
						</aside>
					</section>
				</section>


				<section>
					<section>

						<section>
							<h1>Routing</h1>
							<aside class="notes">
								Matchers attempt to match against HTTP Request. <br />
								Can include Method type, URI Path, and Request Readers <br />
								Maps to Functions that produce responses <br />
								TypeSafe Extraction.
							</aside>
						</section>
				</section>

				<section>
					<section><h2>Let's Build a Something with Finch</h2></section>

					<section>
						<h2>What are we looking to solve?</h2>
						<h3>Simple Commenting Service</h3>

						<aside class="notes">
							Super Contrived Example: <br />
							You have a website that needs a way for users to add comments. <br />
							Anyone can view comments, but only authed users can comment <br />
							We're gonna do a lot of hand waving as a result. <br />
						</aside>
					</section>

					<section>
						<h3>Start the Server</h3>
						<pre>
							<code class="scala">
import io.finch.argonaut._

object Main extends App {
  val config: AppConfig = AppConfig(new CommentThreadRepository)
  val api = CommentThreadEndpoint(config).toService
  Await.ready(Httpx.serve(":8080", api))
}
							</code>
						</pre>
						<aside class="notes">
							Starts an Http server on 8080 using a Service <br />
							The CommentThreadEndpoint is actually an Endpoint (Router)<br />
						</aside>
					</section>

					<section>
						<h2>Get a Comment Thread</h2>
						<pre>
							<code class="scala">
object CommentThreadEndpoint {
  def apply(config: AppConfig) = listComments(config)

  def listComments(config: AppConfig): Router[Seq[CommentThread]] =
    get("thread") { config.commentThreadRepo.list() }
}
							</code>
						</pre>
						<aside class="notes">
							Basic Matcher: Accepts all GETs to /thread <br />
							Calls The Function. <br />
							BUT HOLD ON SERVICES ARE FROM REQUEST => RESPONSE.
							NOT REQUEST => Seq[CommentThread] <br />
							This can't work. Or can it?
						</aside>
					</section>

					<section>
						<h2>Get a specific Comment Thread</h2>
						<pre>
							<code class="scala">
def getCommentThread(config: AppConfig): Router[CommentThread] =
  get("thread" / long) { (id: Long) =>
    config.commentThreadRepo.get(id)
  }
							</code>
						</pre>
						<aside class="notes">
							Arbitrary Long in the request. <br />
							Gets collected, converted and passed to the function that is run <br />
							Type Safe. Won't match if it can't be a long <br />
						</aside>
					</section>

					<section>
						<h2>Add it to the Endpoint</h2>
						<pre>
							<code class="scala">
object CommentThreadEndpoint {
  def apply(config: AppConfig) = {
    listComments(config) :+: getCommentThread(config)
  }
}
							</code>
						</pre>
						<aside class="notes">
							Added to the Router <br />
							But what is happening here? Those Routers don't have the same type. <br />
						</aside>
					</section>

					<section>
						<h2>Creating a comment with Request Readers</h2>
						<pre>
							<code class="scala">
def createComment(config: AppConfig): Router[Comment] = {
  post("thread" / long / "comment" ? commentReader) {
    (threadId: Long, comment: Comment) =>
      config.commentThreadRepo.createComment(threadId, comment)
}
							</code>
						</pre>
						<aside class="notes">
							Use the Req Reader to get a comment <br />
							Reade directly off the body of the request <br />
							What does the commentReader look like? <br />
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h1>Other Goodies</h1>
					</section>

					<section>
						<h2>Request Reader Validation</h2>
						<pre>
							<code class="scala">
val commentParamReader = (
	paramOption("id").as[Long].should("Be Empty") { _.isEmpty } ::
	param("commenter") ::
	body
).as[Comment]
							</code>
						</pre>
					</section>

					<section>
						<h2>JSON Library Support</h2>
						<ul>
							<li>Argonaut</li>
							<li>Circe</li>
							<li>Jackson</li>
							<li>Json4s</li>
						</ul>
					</section>

					<section>
						<h2>File Uploads</h2>
					</section>
				</section>

				<section>
					<section>
						<h1>Questions?</h1>
					</section>

					<section>
						<h1>Thanks!</h1>
					</section>

					<section>
						<h2>Resources</h2>
						<ul>
							<li><a target="_blank" href="http://monkey.org/~marius/funsrv.pdf">Your Server as a Function</a></li>
							<li><a target="_blank" href="https://github.com/finagle/finch/blob/master/docs/index.md">Finch Docs</a></li>
							<li><a target="_blank" href="https://github.com/finagle/finch/tree/master/petstore">Petstore Example</a></li>
							<li><a target="_blank" href="https://github.com/vkostyukov/finch-101">Finch 101</a></li>
						</ul>
					</section>
				</section>

			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});
		</script>
	</body>
</html>
