<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>An Introduction to Finch</title>

		<meta name="description" content="An Introduction to Finch">
		<meta name="author" content="Ryan Plessner">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/solarized.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>
		<div class="reveal">
			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h2>An Introduction to Finch</h2>
					<p>
						<small>Ryan Plessner | <a href="http://twitter.com/ryan_plessner">@ryan_plessner</a></small>
					</p>
				</section>

				<section>
					<section>
						<h2>What is Finch?</h2>
						<img class="no-border" src="https://raw.githubusercontent.com/finagle/finch/master/finch-logo.png"  />
						<br/>
						<a target="_blank" href="https://www.github.com/finagle/finch">github.com/finagle/finch</a>
						<br/>
						<img class="no-border" src="https://travis-ci.org/finagle/finch.svg?branch=master" />
						<img class="no-border" src="http://codecov.io/github/finagle/finch/coverage.svg?branch=master" alt="Coverage via codecov.io" />

						<aside class="notes">
							Twitter Open Source Project in the Finagle ecosystem. <br />
							Provides a more idiomatic and Functional Finagle-Http. <br />
							Its been around since April, I started contributing in August <br />
						</aside>
					</section>

					<section>
						<h2>Built on Finagle</h2>
						<img class="no-border" src="https://camo.githubusercontent.com/5817603f4c475459b07f31d6df1a1cecb29f34dd/68747470733a2f2f7261772e6769746875622e636f6d2f747769747465722f66696e61676c652f6d61737465722f646f632f7372632f737068696e782f5f7374617469632f6c6f676f5f736d616c6c2e706e67" width="360px"/>
						<br />
						<a target="_blank" href="https://twitter.github.io/finagle/">twitter.github.io/finagle/</a>

						<aside class="notes">
							Extensible RPC system for the JVM used mainly to construct high-concurrency systems. <br />
							Protocol Agnostic. <br />
							Particularly interested in the Http library which is built on Netty 3. <br />
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h2>Quick Finagle Overview</h2>
						<aside class="notes">
							Quick review of Finagle's core concepts for those that haven't used it. <br />
							"Your Server as a Function" <br />
							Implements interfaces for both clients and servers <br />
							Only going to focus on Server side. <br />
						</aside>
					</section>
					<section>
						<h2>Futures</h2>
						<ul>
							<li>Featherweight Threads</li>
							<li>Composable</li>
						</ul>

						<aside class="notes">
							Composable Concurrent Operations.  <br />
							Threads are really lightweight.    <br />
							States: Pending, Suceeded, Failed  <br />
							Compose with flatmap and onSuccess <br />
							Recover with recover and onFailure <br />
						</aside>
					</section>

					<section>
						<h2>Services</h2>
						<p>Req => Future[Rep]</p>
					<aside class="notes">
						Implement Application Logic <br />
						Its just a function. <br />
						Backbone of server implementations. <br />
					</aside>
					</section>

					<section>
						<h2>Filters</h2>
						<p>(ReqIn, Service[ReqOut, RepIn]) => Future[RepOut]<p/>

						<aside class="notes">
							Also a function. <br />
							Given a request and the next Service in the Chain. <br />
							Most commonly used where Requests and Responses are the same type. <br />
						</aside>
					</section>

					<section>
						<h3>Filters and Services are Composable</h3>
						<aside class="notes">
							Composed using the andthen function. <br />
							Can compose services and filters <br />
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h1>Finch Basics</h1>
						<p>HTTP Service: Request => Future[Response]</p>
						<aside class="notes">
							Talk about the basic pieces of Finch. <br />
							The Service we care about is from HTTP Requests to HTTP Responses <br />
							Finch makes Heavy use of Shapeless. <br />
						</aside>
					</section>

					<section>
						<h1>Request</h1>
						<pre>
							<code class="scala">
val paramReader = param("foo")
val intReader = passwordReader.as[Int]
val validatedParamReader = intReader.shoul(beLessThan(18))
							</code>
						</pre>
						<aside class="notes">
							Just a Finagle-HTTPX request <br />
							Request Readers: A Reader Monad for handling requests <br />
							Readers for `params`, `headers`, `body`, `files`, and more... <br />
							Decoders convert the Type of Request Readers <br />
							Validation throws errors, if the val in the reader does not conform <br />
							For Comprehensions and Applicative
						</aside>
					</section>

					<section>
						<h1>Response</h1>
						<pre>
							<code class="scala">
val ok = Ok("Hello!")
val created = Created().withHeaders("Some-Header" -> "Some-Value")
							</code>
						</pre>
						<aside class="notes">
							One of these for every response type <br />
							Also have things for cookies and content types <br />
							Encoders for writing out data<br />
							BORING <br />
						</aside>
					</section>

						<section>
							<h1>Router (Endpoint)</h1>
							<pre>
								<code class="scala">
val router = get("commentThread")
								</code>
							</pre>
							<aside class="notes">
								Use HTTP Request to determine if request should be mapped their associated function <br />
								Routers can be combined to make larger Routers <br />
							</aside>
						</section>
				</section>

				<section>
					<section><h2>Let's Build a Something with Finch</h2></section>

					<section>
						<h2>What are we looking to solve?</h2>
						<h3>Simple Commenting Service</h3>

						<aside class="notes">
							Super Contrived Example: <br />
							You have a website that needs a way for users to add comments. <br />
							Anyone can view comments, but only authed users can comment <br />
							We're gonna do a lot of hand waving as a result. <br />
						</aside>
					</section>

					<section>
						<h2>Modeling our data</h2>

						<pre>
							<code class="scala">
case class CommentThread(id: String, comments: Seq[Comment])

case class Comment(id: Option[String], text: String)
							</code>
						</pre>
					</section>

					<section>
						<h3>Start the Server</h3>
						<pre>
							<code class="scala">
import io.finch.argonaut._

object Main extends App {
  val config: AppConfig = AppConfig(new CommentThreadRepository)
  val api = CommentThreadEndpoint(config).toService
  Await.ready(Httpx.serve(":8080", api))
}
							</code>
						</pre>
						<aside class="notes">
							Starts an Http server on 8080 using a Service <br />
							The CommentThreadEndpoint is actually an Endpoint (Router)<br />
						</aside>
					</section>

					<section>
						<h2>Get a Comment Thread</h2>
						<pre>
							<code class="scala">
object CommentThreadEndpoint {
  def apply(config: AppConfig) = listComments(config)

  def listComments(config: AppConfig): Router[Seq[CommentThread]] =
    get("thread") { config.commentThreadRepo.list() }
}
							</code>
						</pre>
						<aside class="notes">
							Basic Router: Accepts all GETs to /thread <br />
							Calls The Function. <br />
							BUT HOLD ON SERVICES ARE FROM REQUEST => RESPONSE.
							NOT REQUEST => Seq[CommentThread] <br />
							This can't work. Or can it?
						</aside>
					</section>

					<section>
						<h2>EncodeResponse</h2>
						<pre>
							<code class="scala">
implicit val commentCodec: CodecJson[Comment] =
  casecodec2(Comment.apply, Comment.unapply)("id", "text")

implicit val commentThreadCodec: CodecJson[CommentThread] =
casecodec2(CommentThread.apply, CommentThread.unapply)("id", "comments")
							</code>
						</pre>
						<aside class="notes">
							Using Finch Argonaut we can convert argonaut Codecs into Decoders and Encoders. <br />
							Similar mechanism for the other Json Libraries.
						</aside>
					</section>

					<section>
						<h2>Get a specific Comment Thread</h2>
						<pre>
							<code class="scala">
def getCommentThread(config: AppConfig): Router[CommentThread] =
  get("thread" / string) { (str: String) =>
    config.commentThreadRepo.get(str)
  }
							</code>
						</pre>
						<aside class="notes">
							Arbitrary String in the request. <br />
							Gets collected and passed to the function that is run <br />
							Type Safe. Uses HList <br />
						</aside>
					</section>

					<section>
						<h2>Creating a comment with Request Readers</h2>
						<pre>
							<code class="scala">
def createComment(config: AppConfig): Router[Comment] = {
  val commentReader = body.as[Comment]
  post("thread" / string / "comment" ? commentReader) {
    (threadId: String, comment: Comment) =>
    config.commentThreadRepo.createComment(threadId, comment)
  }
}
							</code>
						</pre>
					</section>
				</section>

				<section>
					<section>
						<h1>Other Goodies</h1>
					</section>

					<section>
						<h2>JSON Library Support</h2>
						<ul>
							<li>Argonaut</li>
							<li>Circe</li>
							<li>Jackson</li>
							<li>Json4s</li>
						</ul>
					</section>

					<section>
						<h2>File Uploads</h2>
					</section>
				</section>

				<section>
					<section>
						<h1>Questions?</h1>
					</section>

					<section>
						<h1>Thanks!</h1>
					</section>

					<section>
						<h2>Resources</h2>
						<ul>
							<li><a target="_blank" href="http://monkey.org/~marius/funsrv.pdf">Your Server as a Function</a></li>
							<li><a target="_blank" href="https://github.com/finagle/finch/blob/master/docs/index.md">Finch Docs</a></li>
							<li><a target="_blank" href="https://github.com/finagle/finch/tree/master/petstore">Petstore Example</a></li>
							<li><a target="_blank" href="https://github.com/vkostyukov/finch-101">Finch 101</a></li>
						</ul>
					</section>
				</section>

			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});
		</script>
	</body>
</html>
